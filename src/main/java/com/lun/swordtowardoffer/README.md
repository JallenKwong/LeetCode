## 6. 从尾到头打印链表 ##

tag:单向链表

	输入一个链表的头节点，从尾到头反过来打印出每个节点的值。

PS:运用栈或递归方式实现。

[PrintListRecursively](PrintListRecursively.java)


## 7. 重建二叉树 ##

tag:二叉树

	输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。
	假设输入的前序遍历和中序遍历的结果都不含重复的数字。
	例如，输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历{4,7,2,1,5,3,8,6}，
	则重建如下图所示的二叉树并输出它的头节点。

	 1
	/ \
	2 3
	/ /\
	4 5 6
	\  /
	7  8

PS.特别地注意数组下标的标注

[ConstructBinaryTree](ConstructBinaryTree.java)

## 10. 斐波那契数列 ##

tag:数学

	题目一：求斐波那契数列的第n项。
	写一个函数，输入n，求斐波那契数列的第n项。斐波那契数列f(0)=0，f(1)，f(n)=f(n-1)+f(n-2)

	题目二：青蛙跳台阶问题
	一只青蛙一次可跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个n级的台阶总共有多少种跳法

[Fibonacci](Fibonacci.java)

## 15. 二进制中的1的个数 ##

tag:位运算

	实现一个函数，输入一个整数，输出该数二进制表示中1的个数。
	如，9表示成二进制1001，有2位是1.所以，如果输入9，则该函数输出2。

[CountFrequencyOfOne](CountFrequencyOfOne.java)

## 29. 顺时针打印矩阵 ##

tag:编程基础

	输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。例如，如果输入如下矩阵：
	
	1	2	3	4
	5	6	7	8
	9	10	11	12
	13	14	15	16
	
	则依次打印出数字1，2，3，4，8，12，16，15，14，13，9，5，6，7，11，10.

思路：一步一步来，注意最后一圈情况

[ScanMatrixClockwisely](ScanMatrixClockwisely.java)

## 30. 包含min函数的栈 ##

tag:栈

	定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。
	在该栈中，调用min、push、pop的时间复杂度都是O(1)

PS.用多一个栈压入最小值

[MyStack](MyStack.java)

## 31. 栈的压入、弹出序列 ##

tag:stack

	输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列{1,2,3,4,5}是某栈的压栈序列，序列{4,5,3,2,1}是该栈序列对应的一个弹出序列，{4,5,3,2,1}就不能是该压栈序列弹出序列。

[IsPopOrder](IsPopOrder.java)

## 32. 从上到下打印二叉树 ##

tag:二叉树

	题目一：
	从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。
	下面的二叉树打印出来是8,6,10,5,7,9,11

	   8
	  / \
	 6   10
	/ \  / \
	5 7  9 11

[PrintBinaryTreeByLevel](PrintBinaryTreeByLevel.java)

---

	题目二：
	从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。
	下面的二叉树打印出来是
	8
	6 10
	5 7 9 11

	   8
	  / \
	 6   10
	/ \  / \
	5 7  9 11

[PrintBinaryTreeByLevel2](PrintBinaryTreeByLevel2.java)

---

	题目三：之字形打印二叉树
	第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，
	其他行以此类推。
	下面的二叉树打印出来是
	1
	3 2
	4 5 6 7
	15 14 13 12 11 10 9 8

			1
		/		\
	    2         3
	   / \       /  \
	 4    5     6     7
	/ \  / \   / \   / \
	8 9 10 11 12 13 14 15

[PrintBinaryTreeByLevel3](PrintBinaryTreeByLevel3.java)

## 33. 二叉树搜索树的后序遍历序列 ##

tag:二叉树

	输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。
	若是则返回true，否则返回false。
	设输入的数组的任意两个数字互不相同。
	例如{5,7,6,9,11,10,8}，则返回true。{7,4,6,5}则返回false。

	   8
	  / \
	 6   10
	/ \  /\
	5 7 9 11

PS.**后序遍历后得到的数组的最后一元素是跟结点**，然后小于根结点的就是左子树，大于跟结点的就是右子树

[VerifySquenceOfBST](VerifySquenceOfBST.java)

## 34. 二叉树中和为某一值 ##

tag:二叉树

	输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。
	从树的根结点开始往下一直到叶节点所经过的节点形成一路径。

	 10
	 /\
	5 22
	/\
	4 7
	
	该图中有两条和为22的路径：a.10,5,7 b.10,12

PS:二叉树的**前序遍历**

[SumRootToLeafNumber](SumRootToLeafNumber.java)

## 53. 在排序数组中查找数字 ##

tag:二分查找

keyword:已排序数组 查找

思路：充分利用已排序数组的已排序的优势，运用二分查找算法

	题目一：数字在排序数组中出现的次数
	
	统计一个数字在排序数组中出现的次数。
	例如，输入排序数组{1, 2, 3, 3, 3, 3, 4, 5}和数字3，
	由于3在这个数组中出现了4次，因此输出4。

[CountNumberInSortedArray](CountNumberInSortedArray.java)

---

	题目二：0 ~ n-1 中缺失的数字
	
	一个长度为n-1的递增排序数组中的所有数字都是唯一的，
	并且每个数字都在范围0~n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

[FindTheLostNumberInSortedArray](FindTheLostNumberInSortedArray.java)

---

	题目三：假设一个单调递增的数组里的每个元素都是整数并且是唯一的。
	请编写实现一个函数，找出数组中任意一个数值等于其下标的元素。
	例如，在数组{-3, -1, 1, 3, 5}中，数字3和它的下标相等。

PS.认为该题不严谨，字眼“找出数组中任意一个”，暗示得出结果可能有多个，但给出的参考算法却只给出一个返回值。应该数组只有一个数字与它的下标相等。

[FindTheSameOneInSortedArray](FindTheSameOneInSortedArray.java)

## 54. 二叉搜索树的第k大节点 ##

tag:二叉搜索树

	题目：给定一棵二叉搜索树，请找出其中第k大的节点。
	例如，在下面的二叉搜索树里，按节点数值大小顺序，第三大节点的值是4。
	
	   5
	  / \
	 3   7
	/ \ / \
	2 4 6 8

PS.利用**中序遍历**

[GetTheNthNodeInBST](GetTheNthNodeInBST.java)

## 55. 二叉树的深度 ##

tag:二叉树

	题目一：
	输入一棵二叉树的根节点，求该树的深度。
	从根结点到叶节点依次经过的结点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。
	  1
	 /\
	 2 3
	/ \ \
	4  5 6
	  /
	 7
	上面的树的深度为4

PS.可以有高度为1，2，3...的二叉树由低到高理解这递归算法。**前序遍历**

[GetDepthOfBinaryTree](GetDepthOfBinaryTree.java)

---

	题目二：
	输入一棵二叉树的根结点，判断该树是不是平衡二叉树。
	若某二叉树任意结点的左右指数的深度相差不超过1，那么它就是一棵平衡二叉树。
	例如，下图就是一颗平衡二叉树。

	  1
	 /\
	 2 3
	/ \ \
	4  5 6
	  /
	 7

PS.**后序遍历**

[CheckTreeBalanced](CheckTreeBalanced.java)





