# 垃圾收集器与内存分配策略 #

## 概述 ##

1960年诞生于MIT的Lisp是**第一门**真正使用**内存动态分配**和**垃圾收集技术**的语言。

当Lisp还在胚胎期，人们就在思考GC需要完成3件事情：

1. 哪些内存需要回收？
2. 什么时候回收？
3. 如何回收？

经过多年发展，垃圾收集器与内存分配技术日臻完善，**为什么还有去了解GC和内存分配**？

因为当需要排查各种内存溢出、内存泄露问题时，当垃圾收集称为系统达到**更高并发量的瓶颈**时，就需要对这些“自动化”的技术实施必要的**监控**和**调节**。

---

在Java内存运行时区域中，**PCR、 VM Stack、 Native Method Stack 3个区域与线程同生共死**。

栈中的栈帧随着方法的进入和退出而有条不紊地执行者出栈和入栈的操作。每一栈帧中分配多少内存基本上是在类结构确定下俩就已知的。

因此这几个区域内存分配和回收都具备确定性，所以无需多虑，**内存随着方法结束或者线程结束而回收**。

Java堆 和 方法区与这3区域的不同。

一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，这能在程序运行期间才能知道会创建哪些对象，这部分内存分配和回收都是动态。

GC所关注的是这部分内存。


## 对象已死吗 ##

GC在堆进行回收前，第一件事就是要哪些对象是“活”的，哪些是“死”的。

### 引用计数算法 ###

**引用计数算法 Reference Counting**思路：给对象中添加一个**引用计数器**，每当有一个地方引用它时，计数器+1；引用失效时，计数器-1；任何时刻计数器为0的对象就是不可能再被使用。

它的优点：简单高效

但是，主流JVM**未选用**该算法管理内存，其中最主要的原因是**它很难解决对象间相互循环引用的问题**。


两对象相互引用的例子

[ReferenceCountingGC](ReferenceCountingGC.java)

上例侧面说明VM并不是通过引用计数算法来判断对象是否存活的。

PS. 上例没有main方法，另外程序例子运行后如何生成GC日志暂未说明，GC日志内容也未说明。

### 可达性分析算法 ###

Reachability Analysis/əˈnælɪsɪs/

Java、C#、古老Lisp都是通过这种算法来判断对象是否存活。

算法思路：通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为**引用链Reference Chain**，当一对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Root到这个对象不可达）时，则证明此对象是不可用的。

![](image/Reachability-Analysis.png)

在Java语言中，可作为GC Roots的对象包括下面几种：

1. VM Stack(栈帧的本地变量表)中引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中JNI（即一般说的Native方法）引用的对象

### 再谈引用 ###

无论是通过**引用计数算法**判断对象的引用对象，还是**通过可达性分析算法**判断对象的引用链是否可达，判定对象是否存活都与“**引用**”有关。

JDK1.2以前，Java中的引用的定义很传统：若reference类型的数据中存储的数字代表的是另一块内存的起始地址，就称这块内存代表着一个引用。这定义纯粹，但狭隘，一个对象在这种顶一下只有被引用或者没有被引用两种状态。

愿景：有一类对象，当内存空间还足够时，则保留在内存中；若内存空间在进行垃圾收集后还是非常紧张，则可抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。

在JDK1.2后，Java对引用的概念进行了扩充。

1. **强引用StrongReference**指在程序代码中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，GC永不回收掉被引用的对象。
2. **软引用SoftReference**用来描述一些还有用但并非必需的对象。 对于软引用关联着的对象，在系统将要发生**OOME**之前，将会把这些对象列入回收范围之中进行第二次回收。若这次回收还没有足够内存，才会抛出OOME。在JDK1.2后，SoftReference类实现软引用
3. **弱引用WeakReference**用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当GC工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2后，WeakReference类实现弱引用
4. **虚引用PhantomReference**最弱的引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用用来取得一个对象实例。**为一个对象设置虚引用关联的唯一目的就是能在这个对象被GC回收时收到一个系统通知**。在JDK1.2后，PhantomReference类实现虚引用

这4种引用强度依次逐渐减弱。


### 生存还是死亡 ###

[FinalizeEscapeGC](FinalizeEscapeGC.java)





